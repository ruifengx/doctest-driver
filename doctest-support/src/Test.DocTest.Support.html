<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-- | Description: Support functions for @doctest-driver@.</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- Copyright: Copyright 2024, Ruifeng Xie</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- License: LGPL-3.0-or-later</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Maintainer: Ruifeng Xie &lt;ruifengx@outlook.com&gt;</span><span>
</span><span id="line-5"></span><span class="hs-comment">--</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Support functions used by code generated by @doctest-driver@.</span><span>
</span><span id="line-7"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Test.DocTest.Support</span><span>
</span><span id="line-8"></span><span>  </span><span class="hs-comment">-- NOTE: empty lines are significant</span><span>
</span><span id="line-9"></span><span>  </span><span class="hs-comment">-- they prevent sections from being joint with previous paragraphs</span><span>
</span><span id="line-10"></span><span>
</span><span id="line-11"></span><span>  </span><span class="hs-comment">-- | Here we demonstrate features of @doctest-driver@. Readers of this documentation are</span><span>
</span><span id="line-12"></span><span>  </span><span class="hs-comment">-- encouraged to also refer to the source code of this module as an illustration.</span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Examples</span></span><span>
</span><span id="line-15"></span><span>  </span><span class="annot"><span class="hs-comment">-- | @doctest-driver@ supports testing Haddock examples.</span></span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** REPL (Read-Eval-Print-Loop) Style Examples</span></span><span>
</span><span id="line-18"></span><span>  </span><span class="annot"><span class="hs-comment">-- $REPL-Style-Examples</span></span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** QuickCheck Properties</span></span><span>
</span><span id="line-21"></span><span>  </span><span class="annot"><span class="hs-comment">-- $QuickCheck-Properties</span></span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Verbatim Examples</span></span><span>
</span><span id="line-24"></span><span>  </span><span class="annot"><span class="hs-comment">-- $Verbatim-Examples</span></span><span>
</span><span id="line-25"></span><span>
</span><span id="line-26"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Verbatim Properties</span></span><span>
</span><span id="line-27"></span><span>  </span><span class="annot"><span class="hs-comment">-- $Verbatim-Properties</span></span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Support API</span></span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#shouldMatch"><span class="hs-identifier">shouldMatch</span></a></span><span>
</span><span id="line-31"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#ReplResult"><span class="hs-identifier">ReplResult</span></a></span><span>
</span><span id="line-32"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#ReplAction"><span class="hs-identifier">ReplAction</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Captures</span></span><span>
</span><span id="line-35"></span><span>  </span><span class="annot"><span class="hs-comment">-- $Captures</span></span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#withWriteTempFile"><span class="hs-identifier">withWriteTempFile</span></a></span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#textStrict"><span class="hs-identifier">textStrict</span></a></span><span>
</span><span id="line-38"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#textLazy"><span class="hs-identifier">textLazy</span></a></span><span>
</span><span id="line-39"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#byteStringStrict"><span class="hs-identifier">byteStringStrict</span></a></span><span>
</span><span id="line-40"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#byteStringLazy"><span class="hs-identifier">byteStringLazy</span></a></span><span>
</span><span id="line-41"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#shortByteString"><span class="hs-identifier">shortByteString</span></a></span><span>
</span><span id="line-42"></span><span>
</span><span id="line-43"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Hooks</span></span><span>
</span><span id="line-44"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#markUsed"><span class="hs-identifier">markUsed</span></a></span><span>
</span><span id="line-45"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-46"></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.DeepSeq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">deepseq</span></span><span class="hs-special">)</span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Exception</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">throwIO</span></span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">unless</span></span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.ByteString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ByteString</span></span><span class="hs-special">)</span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.ByteString.Lazy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">LazyByteString</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">fromStrict</span></span><span class="hs-special">)</span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.ByteString.Short</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ShortByteString</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">toShort</span></span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/call-stack-0.4.0-73dbd551bf4957cdf7f51ae50132b2a57d206c0b6731d4c467a218b0ed4d73e4/share/doc/html/src/Data.CallStack.html"><span class="hs-identifier">Data.CallStack</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">HasCallStack</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">SrcLoc</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/call-stack-0.4.0-73dbd551bf4957cdf7f51ae50132b2a57d206c0b6731d4c467a218b0ed4d73e4/share/doc/html/src/Data.CallStack.html#callStack"><span class="hs-identifier">callStack</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(:|)</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">N</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">last</span></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Text</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">pack</span></span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text.Encoding</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">encodeUtf8</span></span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text.Lazy</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">TL</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Text</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">pack</span></span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">System.IO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">hClose</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">hPutStr</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">hSetBinaryMode</span></span><span class="hs-special">)</span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/temporary-1.3-ff1d87c3b22ba0b0e71b55492d63985907581fdd1bc1f512fb3232ee77018d48/share/doc/html/src/System.IO.Temp.html"><span class="hs-identifier">System.IO.Temp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/temporary-1.3-ff1d87c3b22ba0b0e71b55492d63985907581fdd1bc1f512fb3232ee77018d48/share/doc/html/src/System.IO.Temp.html#withSystemTempFile"><span class="hs-identifier">withSystemTempFile</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Test.DocTest.FuzzyMatch.html"><span class="hs-identifier">Test.DocTest.FuzzyMatch</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Test.DocTest.FuzzyMatch.html#match"><span class="hs-identifier">match</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Test.DocTest.FuzzySyntax.html"><span class="hs-identifier">Test.DocTest.FuzzySyntax</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Test.DocTest.FuzzySyntax.html#parsePattern"><span class="hs-identifier">parsePattern</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/HUnit-1.6.2.0-306eaa234726934208c2a109bb736b748f9ef6700a559cf2bf2dee4c15657dec/share/doc/html/src/Test.HUnit.Lang.html"><span class="hs-identifier">Test.HUnit.Lang</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/HUnit-1.6.2.0-306eaa234726934208c2a109bb736b748f9ef6700a559cf2bf2dee4c15657dec/share/doc/html/src/Test.HUnit.Lang.html#Assertion"><span class="hs-identifier">Assertion</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/HUnit-1.6.2.0-306eaa234726934208c2a109bb736b748f9ef6700a559cf2bf2dee4c15657dec/share/doc/html/src/Test.HUnit.Lang.html#FailureReason"><span class="hs-identifier">FailureReason</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/HUnit-1.6.2.0-306eaa234726934208c2a109bb736b748f9ef6700a559cf2bf2dee4c15657dec/share/doc/html/src/Test.HUnit.Lang.html#HUnitFailure"><span class="hs-identifier">HUnitFailure</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span>
</span><span id="line-66"></span><span id="local-6989586621679059695"><span class="annot"><a href="Test.DocTest.Support.html#lastMaybe"><span class="hs-identifier hs-type">lastMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679059695"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679059695"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-67"></span><span id="lastMaybe"><span class="annot"><span class="annottext">lastMaybe :: forall a. [a] -&gt; Maybe a
</span><a href="Test.DocTest.Support.html#lastMaybe"><span class="hs-identifier hs-var hs-var">lastMaybe</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-68"></span><span class="annot"><a href="Test.DocTest.Support.html#lastMaybe"><span class="hs-identifier hs-var">lastMaybe</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679059779"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679059779"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679059780"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679059780"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty a -&gt; a
forall a. NonEmpty a -&gt; a
</span><span class="hs-identifier hs-var">N.last</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679059779"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; [a] -&gt; NonEmpty a
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><span class="hs-operator hs-var">:|</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679059780"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span class="annot"><a href="Test.DocTest.Support.html#location"><span class="hs-identifier hs-type">location</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">HasCallStack</span></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">SrcLoc</span></span><span>
</span><span id="line-71"></span><span id="location"><span class="annot"><span class="annottext">location :: HasCallStack =&gt; Maybe SrcLoc
</span><a href="Test.DocTest.Support.html#location"><span class="hs-identifier hs-var hs-var">location</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(String, SrcLoc) -&gt; SrcLoc
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span> </span><span class="annot"><span class="annottext">((String, SrcLoc) -&gt; SrcLoc)
-&gt; Maybe (String, SrcLoc) -&gt; Maybe SrcLoc
forall (f :: Type -&gt; Type) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(String, SrcLoc)] -&gt; Maybe (String, SrcLoc)
forall a. [a] -&gt; Maybe a
</span><a href="Test.DocTest.Support.html#lastMaybe"><span class="hs-identifier hs-var">lastMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">[(String, SrcLoc)]
HasCallStack =&gt; [(String, SrcLoc)]
</span><a href="file:///home/runner/.cabal/store/ghc-9.6.6/call-stack-0.4.0-73dbd551bf4957cdf7f51ae50132b2a57d206c0b6731d4c467a218b0ed4d73e4/share/doc/html/src/Data.CallStack.html#callStack"><span class="hs-identifier hs-var">callStack</span></a></span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span class="hs-keyword">infix</span><span> </span><span class="hs-number">1</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#shouldMatch"><span class="hs-operator hs-type">`shouldMatch`</span></a></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span class="annot"><span class="hs-comment">{- $setup
&gt;&gt;&gt; import Control.Exception (try)
&gt;&gt;&gt; import Test.HUnit.Lang
&gt;&gt;&gt; import Test.DocTest.FuzzyMatch
&gt;&gt;&gt; import Test.DocTest.FuzzySyntax
-}</span></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span class="annot"><span class="hs-comment">{- $REPL-Style-Examples

Each example is one program line starting with @&gt;&gt;&gt;@ followed by zero or more result lines.

&gt;&gt;&gt; &quot;hello&quot; ++ &quot;, &quot; ++ &quot;world&quot;
&quot;hello, world&quot;

Since @doctest-driver@ extracts the doctests to a test suite and does not rely on GHCi, there
are some subtle edge cases to be aware of.

1. GHCi supports evaluating both pure values and 'IO' actions. @doctest-driver@ also supports
this via the type class 'ReplAction' and type family 'ReplResult'. As a result, if the target
expression to be evaluated has a polymorphic type (in technical terms, the type is not specific
enough to determine whether it matches @'IO' a@ or not), the generated test suite will fail to
compile. To fix the issue, add a type signature or use @TypeApplications@ to disambiguate.

    &gt; -- this will not work
    &gt; &gt;&gt;&gt; 6 * 7
    &gt; 42

    &gt;&gt;&gt; (6 * 7) :: Int
    42

2. GHCi displays the result as a string by calling 'show'. The well-known @doctest@ library
additionally supports fuzzy result matching. To replicate these behaviours, we also call 'show'
on the program line expression, and perform fuzzy matching against the expected output lines.
This fuzzy matching is implemented in &quot;Test.DocTest.FuzzyMatch&quot;. See 'shouldMatch' for examples.

3. Haddock renders examples adjacent to each other (i.e., not separated by one or more empty
lines) as a single code block. Therefore, we generate one single @do@-block for each such
example block, which means local variables bound by @let@ or monadic bind (@&lt;-@) are in scope
up until the current example block ends. To introduce variables shared by multiple example
groups, use one of the hook instructions explained below.

    &gt;&gt;&gt; let x = 3 :: Int
    &gt;&gt;&gt; -- x is now in scope
    &gt;&gt;&gt; x + 1
    4

4. The evaluator plugin in haskell-language-server (HLS) allows writing multiple examples to
be evaluated, and then (following all the examples) all of their results. This requires some
efforts to implement correctly. Additionally, this style makes it harder to tell which output
line comes from which test example, since it is possible for a single test example to have
multiple lines of output. Therefore, we do not support this style.

    &gt; -- this is not supported
    &gt; &gt;&gt;&gt; 1 + 1 :: Int
    &gt; &gt;&gt;&gt; 6 * 7 :: Int
    &gt; 2
    &gt; 42

    The above test case would attempt run @1 + 1 :: Int@ as an 'IO' action, and compare the
    result of @6 * 7 :: Int@ (after calling 'show' as explained above) with the two output
    lines, which results in compile errors. The tests should be written as follows, instead:

    &gt;&gt;&gt; 1 + 1 :: Int
    2
    &gt;&gt;&gt; 6 * 7 :: Int
    42

5. GHCi allows type definitions and function definitions without @let@. Since examples are put
into @do@-blocks, neither type definitions nor function definitions are allowed. To introduce
such definitions, you must promote them to the top-level using one of the @setup@ instructions
explained below. Alternatively, functions can still be defined locally using @let@.

6. GHCi supports various commands starting with a colon (@:@). Since we do not use GHCi, these
commands are not supported in @doctest-driver@. Among all the commands, @:{@ and @:}@ are used
to start and close multiline expressions and definitions in GHCi. The @doctest@ library takes
this syntax and supports multiline test cases as follows:

    &gt; &gt;&gt;&gt; :{
    &gt; first line
    &gt;   second line (indented)
    &gt;   more lines
    &gt; :}
    &gt; first line of expected output
    &gt; more output lines

    Note the lack of @&gt;&gt;&gt;@ markers for line 2-5: it is a clever trick to avoid the indentation
    from being removed by Haddock. However, strictly speaking (from Haddock's perspective),
    this test consist of a single line of code (@:{@) and five lines lines of expected output.
    Over all, this syntax does not render in the same way as the test writer, and may look
    confusing to users. @doctest-driver@ does not support this syntax. For multiline tests
    and properties, one should use verbatim code blocks with appropriate doctest instructions
    (@test@ and @property@ respectively) as explained in the following sections.
-}</span></span><span>
</span><span id="line-168"></span><span>
</span><span id="line-169"></span><span class="annot"><span class="hs-comment">{- $QuickCheck-Properties

Each QuickCheck property is one program line starting with @prop&gt;@. Typically, a property is
written as a lambda expression, with multiple parameters (considered universally quantified).
The @doctest@ library allows omitting the binders; under the hood, it uses GHCi to collect the
free variables (by type-checking the expression and parsing the error messages) and implicitly
add lambda abstractions for them. QuickCheck relies on the @Arbitrary@ type class for random
generation, and thus the properties must be specific enough. The @doctest@ library uses the
@polyQuickCheck@ function (provided by QuickCheck, dependent on Template Haskell) to test the
properties, which defaults all type variables to 'Integer', making the properties monomorphic.

@doctest-driver@ cannot rely on GHCi, and it is hard to use Template Haskell (due to its phase
restrictions) in generated tests. Therefore, neither of the above features is supported. All
the free variables must be introduced explicitly through the lambda abstraction, and all input
variables should have a monomorphic type (possibly by adding type annotations).

prop&gt; \(xs :: [Int]) -&gt; reverse (reverse xs) == xs

This example above describes the well-recognised property for the 'reverse' function. Notice
the explicit lambda abstraction and the accompanying type annotation.
-}</span></span><span>
</span><span id="line-190"></span><span>
</span><span id="line-191"></span><span class="annot"><span class="hs-comment">{- $Verbatim-Examples

Haddock also allows verbatim code blocks, with each line preceded by a bird track (@&gt;@). To
make such code blocks work as tests, use the @test@ instruction as follows:

&gt; -- doctest:test
&gt; (1 + 1) `shouldBe` (2 :: Int)

These examples are implicitly put into a @do@ block for the 'IO' monad, and the whole block is
copied verbatim into the generated text (except adjusting the indentation). Unlike REPL-style
examples, we cannot specify expected output lines, and the comparison must be done explicitly.

Verbatim examples are more flexible than REPL-style examples.

First, REPL-style examples call 'show' on the result to compare with the expected output lines.
When the result type does not implement 'Show', or when the 'Show' instance does not provide
sufficient meaningful information, REPL-style examples are not suitable.

Second, Haddock strips leading whitespace from test lines in REPL-style examples. To ensure the
behaviour of test examples is consistent with the way they are rendered, @doctest-driver@ also
strips the leading whitespace. This means REPL-style examples are not suitable for multiline
test cases with indentation.
-}</span></span><span>
</span><span id="line-214"></span><span>
</span><span id="line-215"></span><span class="annot"><span class="hs-comment">{- $Verbatim-Properties

Haddock only supports single-line properties. For multiline properties, one can write them as
verbatim examples by calling the @property@ function from QuickCheck:

&gt; -- doctest:setup-import
&gt; import Test.QuickCheck

(This @setup-import@ block adds an @import@ statement to the generated module. The details will
be explained in later sections, and readers can safely ignore it for now.)

&gt; -- doctest:test
&gt; property $ \(xs :: [Int]) -&gt;
&gt;   reverse (reverse xs) == xs

For this specific use case, @doctest-driver@ also provides the @property@ instruction to write
verbatim properties. One should prefer the following (using @property@) over the above (using
@test@ and call @property@ explicitly) to better express the intention concisely:

&gt; -- doctest:property
&gt; \(xs :: [Int]) -&gt;
&gt;   reverse (reverse xs) == xs
-}</span></span><span>
</span><span id="line-238"></span><span>
</span><span id="line-239"></span><span class="annot"><span class="hs-comment">{- $Captures

Sometimes we need some textual contents in our tests, and it might also be useful to let the
user see them while browsing the documentation. In such cases, we can use the @capture@
instruction in a verbatim code block. The whole block is unindented by stripping the common
whitespace prefix. The captured text does not contain a trailing @\'\\n\'@ character. To force
adding one, leave an empty line at the end of the verbatim code block.

It is most natural to start with the test cases making use of the captured variable:

&gt;&gt;&gt; take 15 stringCapture
&quot;This text block&quot;
&gt;&gt;&gt; length (lines stringCapture)
2

and show its contents afterwards:

&gt; -- doctest:capture(stringCapture :: String)
&gt; This text block is supposed to be captured as a String variable.
&gt; Everything besides the first line (the doctest instruction) is captured verbatim.

Sometimes, our tests expect the contents to be saved somewhere as a file. The @capture@
instruction conveniently allow specifying the variable to have type 'FilePath' in such cases:

&gt; -- doctest:capture(fileCapture :: FilePath)
&gt; This text block will be saved to a temporary file.
&gt; The file is written once and reused for all test cases in this group.
&gt; Therefore, it is only suitable for reading.
&gt; For advanced usage involving editing and deletion, use a String capture with a &quot;before&quot; or &quot;around&quot; hook.

The @fileCapture :: 'FilePath'@ variable is then available for use.

&gt;&gt;&gt; fileContents &lt;- readFile fileCapture
&gt;&gt;&gt; length (lines fileContents)
4
&gt;&gt;&gt; lines fileContents !! 2
&quot;Therefore, it is only suitable for reading.&quot;

We can also capture texts as @Text@s and @ByteString@s (strict or lazy).

For strict 'T.Text', use @Text@ or @Strict.Text@:

&gt; -- doctest:capture(captureStrictText :: Text)
&gt; strict text

&gt; -- doctest:capture(captureStrictTextAlt :: Strict.Text)
&gt; strict text

&gt;&gt;&gt; captureStrictText :: T.Text
&quot;strict text&quot;
&gt;&gt;&gt; captureStrictText == captureStrictTextAlt
True

For lazy 'TL.Text', use @Lazy.Text@:

&gt; -- doctest:capture(captureLazyText :: Lazy.Text)
&gt; lazy text

&gt;&gt;&gt; captureLazyText :: TL.Text
&quot;lazy text&quot;

The same applies to strict and lazy 'ByteString's, as well as 'ShortByteString's:

&gt; -- doctest:capture(captureStrictByteString :: ByteString)
&gt; strict byte string

&gt; -- doctest:capture(captureStrictByteStringAlt :: Strict.ByteString)
&gt; strict byte string

&gt; -- doctest:capture(captureLazyByteString :: Lazy.ByteString)
&gt; lazy byte string

&gt; -- doctest:capture(captureShortByteString :: ShortByteString)
&gt; short byte string

&gt;&gt;&gt; captureStrictByteString :: ByteString
&quot;strict byte string&quot;
&gt;&gt;&gt; captureStrictByteString == captureStrictByteStringAlt
True

&gt;&gt;&gt; captureLazyByteString :: LazyByteString
&quot;lazy byte string&quot;

&gt;&gt;&gt; captureShortByteString :: ShortByteString
&quot;short byte string&quot;

@doctest-driver@ will take care of correctly wrapping the text contents into the requested
types. For byte strings, the text is encoded as UTF-8. No extra import is required for the
captures themselves, but in order to use them in a meaningful way, one may still need to add
explicit dependency on the @text@ and @bytestring@ packages, and import the required modules.
In this example, we use type ascriptions to assert that the captured variables have the
expected type, which requires the following imports:

&gt; -- doctest:setup-import
&gt; import qualified Data.Text as T (Text)
&gt; import qualified Data.Text.Lazy as TL (Text)
&gt; import Data.ByteString (ByteString)
&gt; import Data.ByteString.Lazy (LazyByteString)
&gt; import Data.ByteString.Short (ShortByteString)

If your specific use case requires capturing text in encodings other than UTF-8, you can use
'String' capture and do the encoding yourself. We expect UTF-8 to be enough for most use cases.
-}</span></span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span class="hs-comment">-- | Expect that the value @a@, when 'show'n, 'match'es the pattern string.</span><span>
</span><span id="line-344"></span><span class="hs-comment">--</span><span>
</span><span id="line-345"></span><span class="hs-comment">-- Simple usage: no pattern in the pattern string.</span><span>
</span><span id="line-346"></span><span class="hs-comment">--</span><span>
</span><span id="line-347"></span><span class="hs-comment">-- &gt;&gt;&gt; try @HUnitFailure ((123 :: Int) `shouldMatch` &quot;123&quot;)</span><span>
</span><span id="line-348"></span><span class="hs-comment">-- Right ()</span><span>
</span><span id="line-349"></span><span class="hs-comment">-- &gt;&gt;&gt; try @HUnitFailure ((123 :: Int) `shouldMatch` &quot;000&quot;)</span><span>
</span><span id="line-350"></span><span class="hs-comment">-- Left (HUnitFailure (Just (SrcLoc {...})) (ExpectedButGot Nothing &quot;000&quot; &quot;123&quot;))</span><span>
</span><span id="line-351"></span><span class="hs-comment">-- &gt;&gt;&gt; try @HUnitFailure (&quot;&#27979;&#35797;&#171;&#945;&#946;&#187;&quot; `shouldMatch` &quot;\&quot;\\27979\\35797\\171\\945\\946\\187\&quot;&quot;)</span><span>
</span><span id="line-352"></span><span class="hs-comment">-- Right ()</span><span>
</span><span id="line-353"></span><span class="hs-comment">--</span><span>
</span><span id="line-354"></span><span class="hs-comment">-- Advanced usage: @...@ for inline and multiline wildcard.</span><span>
</span><span id="line-355"></span><span class="hs-comment">--</span><span>
</span><span id="line-356"></span><span class="hs-comment">-- &gt;&gt;&gt; try @HUnitFailure (True `shouldMatch` &quot;T...e&quot;)</span><span>
</span><span id="line-357"></span><span class="hs-comment">-- Right ()</span><span>
</span><span id="line-358"></span><span class="hs-comment">-- &gt;&gt;&gt; try @HUnitFailure (&quot;some fancy string&quot; `shouldMatch` &quot;\&quot;some ... string\&quot;&quot;)</span><span>
</span><span id="line-359"></span><span class="hs-comment">-- Right ()</span><span>
</span><span id="line-360"></span><span class="hs-comment">--</span><span>
</span><span id="line-361"></span><span class="hs-comment">-- &gt; -- doctest:setup-top</span><span>
</span><span id="line-362"></span><span class="hs-comment">-- &gt; data Verbatim = Verbatim String</span><span>
</span><span id="line-363"></span><span class="hs-comment">-- &gt; instance Show Verbatim where show (Verbatim s) = s</span><span>
</span><span id="line-364"></span><span class="hs-comment">--</span><span>
</span><span id="line-365"></span><span class="hs-comment">-- &gt;&gt;&gt; try @HUnitFailure (Verbatim &quot;aaa\n\nbbb&quot; `shouldMatch` &quot;aaa\n...\nbbb&quot;)</span><span>
</span><span id="line-366"></span><span class="hs-comment">-- Right ()</span><span>
</span><span id="line-367"></span><span class="hs-comment">-- &gt;&gt;&gt; try @HUnitFailure (Verbatim &quot;aaa\nccc\nddd\nbbb&quot; `shouldMatch` &quot;aaa\n...\nbbb&quot;)</span><span>
</span><span id="line-368"></span><span class="hs-comment">-- Right ()</span><span>
</span><span id="line-369"></span><span id="local-6989586621679059707"><span class="annot"><a href="Test.DocTest.Support.html#shouldMatch"><span class="hs-identifier hs-type">shouldMatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HasCallStack</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#ReplAction"><span class="hs-identifier hs-type">ReplAction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679059707"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Test.DocTest.Support.html#ReplResult"><span class="hs-identifier hs-type">ReplResult</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679059707"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679059707"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.6/HUnit-1.6.2.0-306eaa234726934208c2a109bb736b748f9ef6700a559cf2bf2dee4c15657dec/share/doc/html/src/Test.HUnit.Lang.html#Assertion"><span class="hs-identifier hs-type">Assertion</span></a></span></span><span>
</span><span id="line-370"></span><span id="shouldMatch"><span class="annot"><span class="annottext">shouldMatch :: forall a.
(HasCallStack, ReplAction a, Show (ReplResult a)) =&gt;
a -&gt; String -&gt; Assertion
</span><a href="Test.DocTest.Support.html#shouldMatch"><span class="hs-identifier hs-var hs-var">shouldMatch</span></a></span></span><span> </span><span id="local-6989586621679059812"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679059812"><span class="hs-identifier hs-var">actual</span></a></span></span><span> </span><span id="local-6989586621679059813"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059813"><span class="hs-identifier hs-var">expected</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-371"></span><span>  </span><span id="local-6989586621679059814"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059814"><span class="hs-identifier hs-var">sActual</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ReplResult a -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">(ReplResult a -&gt; String) -&gt; IO (ReplResult a) -&gt; IO String
forall (f :: Type -&gt; Type) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; IO (ReplResult a)
forall a. ReplAction a =&gt; a -&gt; IO (ReplResult a)
</span><a href="Test.DocTest.Support.html#replAction"><span class="hs-identifier hs-var">replAction</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679059812"><span class="hs-identifier hs-var">actual</span></a></span><span>
</span><span id="line-372"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679059816"><span class="annot"><span class="annottext">err :: HUnitFailure
</span><a href="#local-6989586621679059816"><span class="hs-identifier hs-var hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe SrcLoc -&gt; FailureReason -&gt; HUnitFailure
</span><a href="file:///home/runner/.cabal/store/ghc-9.6.6/HUnit-1.6.2.0-306eaa234726934208c2a109bb736b748f9ef6700a559cf2bf2dee4c15657dec/share/doc/html/src/Test.HUnit.Lang.html#HUnitFailure"><span class="hs-identifier hs-var">HUnitFailure</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe SrcLoc
HasCallStack =&gt; Maybe SrcLoc
</span><a href="Test.DocTest.Support.html#location"><span class="hs-identifier hs-var">location</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe String -&gt; String -&gt; String -&gt; FailureReason
</span><a href="file:///home/runner/.cabal/store/ghc-9.6.6/HUnit-1.6.2.0-306eaa234726934208c2a109bb736b748f9ef6700a559cf2bf2dee4c15657dec/share/doc/html/src/Test.HUnit.Lang.html#ExpectedButGot"><span class="hs-identifier hs-var">ExpectedButGot</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe String
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059813"><span class="hs-identifier hs-var">expected</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059814"><span class="hs-identifier hs-var">sActual</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-373"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679059819"><span class="annot"><span class="annottext">onError :: Assertion
</span><a href="#local-6989586621679059819"><span class="hs-identifier hs-var hs-var">onError</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059813"><span class="hs-identifier hs-var">expected</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; Assertion -&gt; Assertion
forall a b. NFData a =&gt; a -&gt; b -&gt; b
</span><span class="hs-operator hs-var">`deepseq`</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059814"><span class="hs-identifier hs-var">sActual</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; Assertion -&gt; Assertion
forall a b. NFData a =&gt; a -&gt; b -&gt; b
</span><span class="hs-operator hs-var">`deepseq`</span></span><span> </span><span class="annot"><span class="annottext">HUnitFailure -&gt; Assertion
forall e a. Exception e =&gt; e -&gt; IO a
</span><span class="hs-identifier hs-var">throwIO</span></span><span> </span><span class="annot"><span class="annottext">HUnitFailure
</span><a href="#local-6989586621679059816"><span class="hs-identifier hs-var">err</span></a></span><span>
</span><span id="line-374"></span><span>  </span><span class="annot"><span class="annottext">Bool -&gt; Assertion -&gt; Assertion
forall (f :: Type -&gt; Type). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pattern -&gt; String -&gt; Bool
</span><a href="Test.DocTest.FuzzyMatch.html#match"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Pattern
</span><a href="Test.DocTest.FuzzySyntax.html#parsePattern"><span class="hs-identifier hs-var">parsePattern</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059813"><span class="hs-identifier hs-var">expected</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059814"><span class="hs-identifier hs-var">sActual</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Assertion
</span><a href="#local-6989586621679059819"><span class="hs-identifier hs-var">onError</span></a></span><span>
</span><span id="line-375"></span><span>
</span><span id="line-376"></span><span class="hs-comment">-- | Result type of running as a 'ReplAction'. Unfortunately, this cannot handle polymorphic types</span><span>
</span><span id="line-377"></span><span class="hs-comment">-- without a known top-level type constructor.</span><span>
</span><span id="line-378"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="ReplResult"><span class="annot"><a href="Test.DocTest.Support.html#ReplResult"><span class="hs-identifier hs-var">ReplResult</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679059820"><span class="annot"><a href="#local-6989586621679059820"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-379"></span><span>  </span><span id="ReplResult"><span class="annot"><a href="Test.DocTest.Support.html#ReplResult"><span class="hs-identifier hs-var">ReplResult</span></a></span></span><span> </span><span id="local-6989586621679059821"><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621679059821"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679059821"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-380"></span><span>  </span><span id="ReplResult"><span class="annot"><a href="Test.DocTest.Support.html#ReplResult"><span class="hs-identifier hs-var">ReplResult</span></a></span></span><span> </span><span id="local-6989586621679059822"><span class="annot"><a href="#local-6989586621679059822"><span class="hs-identifier hs-type hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679059822"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-381"></span><span>
</span><span id="line-382"></span><span class="hs-comment">-- | GHCi session supports both evaluating pure values and running 'IO' actions. Use this type</span><span>
</span><span id="line-383"></span><span class="hs-comment">-- class to let the compiler deduce which one a test line should use.</span><span>
</span><span id="line-384"></span><span class="hs-keyword">class</span><span> </span><span id="ReplAction"><span class="annot"><a href="Test.DocTest.Support.html#ReplAction"><span class="hs-identifier hs-var">ReplAction</span></a></span></span><span> </span><span id="local-6989586621679059717"><span class="annot"><a href="#local-6989586621679059717"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-385"></span><span>  </span><span class="hs-comment">-- | Embed into an 'IO' action.</span><span>
</span><span id="line-386"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-387"></span><span>  </span><span class="hs-comment">-- &gt;&gt;&gt; replAction (123 :: Int)</span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-comment">-- 123</span><span>
</span><span id="line-389"></span><span>  </span><span class="hs-comment">-- &gt;&gt;&gt; replAction (pure 123 :: IO Int)</span><span>
</span><span id="line-390"></span><span>  </span><span class="hs-comment">-- 123</span><span>
</span><span id="line-391"></span><span>  </span><span id="replAction"><span class="annot"><a href="Test.DocTest.Support.html#replAction"><span class="hs-identifier hs-type">replAction</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679059717"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Test.DocTest.Support.html#ReplResult"><span class="hs-identifier hs-type">ReplResult</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679059717"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-392"></span><span>
</span><span id="line-393"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679059726"><span class="annot"><a href="#local-6989586621679059726"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~</span></span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#ReplResult"><span class="hs-identifier hs-type">ReplResult</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679059726"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#ReplAction"><span class="hs-identifier hs-type">ReplAction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679059726"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-394"></span><span>  </span><span id="local-6989586621679059830"><span class="annot"><span class="annottext">replAction :: a -&gt; IO (ReplResult a)
</span><a href="Test.DocTest.Support.html#replAction"><span class="hs-identifier hs-var hs-var hs-var hs-var">replAction</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; IO a
a -&gt; IO (ReplResult a)
forall a. a -&gt; IO a
forall (f :: Type -&gt; Type) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-395"></span><span>
</span><span id="line-396"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-pragma">{-# OVERLAPPING</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span id="local-6989586621679059732"><span class="annot"><a href="Test.DocTest.Support.html#ReplAction"><span class="hs-identifier hs-type">ReplAction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621679059732"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-397"></span><span>  </span><span id="local-6989586621679059833"><span class="annot"><span class="annottext">replAction :: IO a -&gt; IO (ReplResult (IO a))
</span><a href="Test.DocTest.Support.html#replAction"><span class="hs-identifier hs-var hs-var hs-var hs-var">replAction</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IO a -&gt; IO a
IO a -&gt; IO (ReplResult (IO a))
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-398"></span><span>
</span><span id="line-399"></span><span class="hs-comment">-- | Create a temporary file, write the given contents, run the action with the 'FilePath', and</span><span>
</span><span id="line-400"></span><span class="hs-comment">-- remove the file at last. Used to implement 'FilePath' captures.</span><span>
</span><span id="line-401"></span><span id="local-6989586621679059734"><span class="annot"><a href="Test.DocTest.Support.html#withWriteTempFile"><span class="hs-identifier hs-type">withWriteTempFile</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621679059734"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621679059734"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-402"></span><span id="withWriteTempFile"><span class="annot"><span class="annottext">withWriteTempFile :: forall a. (String -&gt; IO a) -&gt; String -&gt; IO a
</span><a href="Test.DocTest.Support.html#withWriteTempFile"><span class="hs-identifier hs-var hs-var">withWriteTempFile</span></a></span></span><span> </span><span id="local-6989586621679059842"><span class="annot"><span class="annottext">String -&gt; IO a
</span><a href="#local-6989586621679059842"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679059843"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059843"><span class="hs-identifier hs-var">contents</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; (String -&gt; Handle -&gt; IO a) -&gt; IO a
forall (m :: Type -&gt; Type) a.
(MonadIO m, MonadMask m) =&gt;
String -&gt; (String -&gt; Handle -&gt; m a) -&gt; m a
</span><a href="file:///home/runner/.cabal/store/ghc-9.6.6/temporary-1.3-ff1d87c3b22ba0b0e71b55492d63985907581fdd1bc1f512fb3232ee77018d48/share/doc/html/src/System.IO.Temp.html#withSystemTempFile"><span class="hs-identifier hs-var">withSystemTempFile</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;doctest.txt&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Handle -&gt; IO a
</span><a href="#local-6989586621679059844"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-403"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679059844"><span class="annot"><span class="annottext">go :: String -&gt; Handle -&gt; IO a
</span><a href="#local-6989586621679059844"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679059845"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059845"><span class="hs-identifier hs-var">path</span></a></span></span><span> </span><span id="local-6989586621679059846"><span class="annot"><span class="annottext">Handle
</span><a href="#local-6989586621679059846"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Handle -&gt; Bool -&gt; Assertion
</span><span class="hs-identifier hs-var">hSetBinaryMode</span></span><span> </span><span class="annot"><span class="annottext">Handle
</span><a href="#local-6989586621679059846"><span class="hs-identifier hs-var">h</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Assertion -&gt; Assertion -&gt; Assertion
forall a b. IO a -&gt; IO b -&gt; IO b
forall (f :: Type -&gt; Type) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Handle -&gt; String -&gt; Assertion
</span><span class="hs-identifier hs-var">hPutStr</span></span><span> </span><span class="annot"><span class="annottext">Handle
</span><a href="#local-6989586621679059846"><span class="hs-identifier hs-var">h</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059843"><span class="hs-identifier hs-var">contents</span></a></span><span> </span><span class="annot"><span class="annottext">Assertion -&gt; Assertion -&gt; Assertion
forall a b. IO a -&gt; IO b -&gt; IO b
forall (f :: Type -&gt; Type) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Handle -&gt; Assertion
</span><span class="hs-identifier hs-var">hClose</span></span><span> </span><span class="annot"><span class="annottext">Handle
</span><a href="#local-6989586621679059846"><span class="hs-identifier hs-var">h</span></a></span><span> </span><span class="annot"><span class="annottext">Assertion -&gt; IO a -&gt; IO a
forall a b. IO a -&gt; IO b -&gt; IO b
forall (f :: Type -&gt; Type) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; IO a
</span><a href="#local-6989586621679059842"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679059845"><span class="hs-identifier hs-var">path</span></a></span><span>
</span><span id="line-404"></span><span>
</span><span id="line-405"></span><span class="annot"><span class="hs-comment">-- | Convert a string to strict text.</span></span><span>
</span><span id="line-406"></span><span class="annot"><a href="Test.DocTest.Support.html#textStrict"><span class="hs-identifier hs-type">textStrict</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">T.Text</span></span><span>
</span><span id="line-407"></span><span id="textStrict"><span class="annot"><span class="annottext">textStrict :: String -&gt; Text
</span><a href="Test.DocTest.Support.html#textStrict"><span class="hs-identifier hs-var hs-var">textStrict</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Text
</span><span class="hs-identifier hs-var">T.pack</span></span><span>
</span><span id="line-408"></span><span>
</span><span id="line-409"></span><span class="annot"><span class="hs-comment">-- | Convert a string to lazy text.</span></span><span>
</span><span id="line-410"></span><span class="annot"><a href="Test.DocTest.Support.html#textLazy"><span class="hs-identifier hs-type">textLazy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TL.Text</span></span><span>
</span><span id="line-411"></span><span id="textLazy"><span class="annot"><span class="annottext">textLazy :: String -&gt; Text
</span><a href="Test.DocTest.Support.html#textLazy"><span class="hs-identifier hs-var hs-var">textLazy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Text
</span><span class="hs-identifier hs-var">TL.pack</span></span><span>
</span><span id="line-412"></span><span>
</span><span id="line-413"></span><span class="annot"><span class="hs-comment">-- | Convert a string to strict byte string.</span></span><span>
</span><span id="line-414"></span><span class="annot"><a href="Test.DocTest.Support.html#byteStringStrict"><span class="hs-identifier hs-type">byteStringStrict</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ByteString</span></span><span>
</span><span id="line-415"></span><span id="byteStringStrict"><span class="annot"><span class="annottext">byteStringStrict :: String -&gt; ByteString
</span><a href="Test.DocTest.Support.html#byteStringStrict"><span class="hs-identifier hs-var hs-var">byteStringStrict</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text -&gt; ByteString
</span><span class="hs-identifier hs-var">T.encodeUtf8</span></span><span> </span><span class="annot"><span class="annottext">(Text -&gt; ByteString) -&gt; (String -&gt; Text) -&gt; String -&gt; ByteString
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Text
</span><a href="Test.DocTest.Support.html#textStrict"><span class="hs-identifier hs-var">textStrict</span></a></span><span>
</span><span id="line-416"></span><span>
</span><span id="line-417"></span><span class="annot"><span class="hs-comment">-- | Convert a string to lazy byte string.</span></span><span>
</span><span id="line-418"></span><span class="annot"><a href="Test.DocTest.Support.html#byteStringLazy"><span class="hs-identifier hs-type">byteStringLazy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">LazyByteString</span></span><span>
</span><span id="line-419"></span><span id="byteStringLazy"><span class="annot"><span class="annottext">byteStringLazy :: String -&gt; LazyByteString
</span><a href="Test.DocTest.Support.html#byteStringLazy"><span class="hs-identifier hs-var hs-var">byteStringLazy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ByteString -&gt; LazyByteString
</span><span class="hs-identifier hs-var">fromStrict</span></span><span> </span><span class="annot"><span class="annottext">(ByteString -&gt; LazyByteString)
-&gt; (String -&gt; ByteString) -&gt; String -&gt; LazyByteString
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ByteString
</span><a href="Test.DocTest.Support.html#byteStringStrict"><span class="hs-identifier hs-var">byteStringStrict</span></a></span><span>
</span><span id="line-420"></span><span>
</span><span id="line-421"></span><span class="annot"><span class="hs-comment">-- | Convert a string to short byte string.</span></span><span>
</span><span id="line-422"></span><span class="annot"><a href="Test.DocTest.Support.html#shortByteString"><span class="hs-identifier hs-type">shortByteString</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ShortByteString</span></span><span>
</span><span id="line-423"></span><span id="shortByteString"><span class="annot"><span class="annottext">shortByteString :: String -&gt; ShortByteString
</span><a href="Test.DocTest.Support.html#shortByteString"><span class="hs-identifier hs-var hs-var">shortByteString</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ByteString -&gt; ShortByteString
</span><span class="hs-identifier hs-var">toShort</span></span><span> </span><span class="annot"><span class="annottext">(ByteString -&gt; ShortByteString)
-&gt; (String -&gt; ByteString) -&gt; String -&gt; ShortByteString
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ByteString
</span><a href="Test.DocTest.Support.html#byteStringStrict"><span class="hs-identifier hs-var">byteStringStrict</span></a></span><span>
</span><span id="line-424"></span><span>
</span><span id="line-425"></span><span class="annot"><span class="hs-comment">-- | No-op function. Used to silence the &quot;variable unused&quot; warning.</span></span><span>
</span><span id="line-426"></span><span id="local-6989586621679059751"><span class="annot"><a href="Test.DocTest.Support.html#markUsed"><span class="hs-identifier hs-type">markUsed</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679059751"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-427"></span><span id="markUsed"><span class="annot"><span class="annottext">markUsed :: forall a. a -&gt; Assertion
</span><a href="Test.DocTest.Support.html#markUsed"><span class="hs-identifier hs-var hs-var">markUsed</span></a></span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Assertion
forall a. a -&gt; IO a
forall (f :: Type -&gt; Type) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-428"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Test.DocTest.Support.html#markUsed"><span class="hs-pragma hs-type">markUsed</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-429"></span></pre></body></html>