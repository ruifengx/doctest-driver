-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | DocTest support library for code generated by doctest-driver.
--   
--   DocTest support library for code generated by doctest-driver.
@package doctest-support
@version 0.1.0.0


-- | Fuzzy pattern syntax used for doctest output text segments.
module Test.DocTest.FuzzySyntax

-- | Pattern string.
type Pattern = [Segment]

-- | Pattern segment.
data Segment

-- | "<tt>&lt;BLANKLINE&gt;</tt>" for empty lines.
BlankLine :: Segment

-- | "<tt>...</tt>" on its own line, matching one or more arbitrary lines.
MultilineDots :: Segment

-- | "<tt>...</tt>" in the middle of line, matching one or more non-newline
--   characters.
InlineDots :: Segment

-- | Other plain string, matched verbatim.
Plain :: String -> Segment

-- | Parsing the pattern string into a <a>Pattern</a> structure.
parsePattern :: String -> Pattern
instance GHC.Show.Show Test.DocTest.FuzzySyntax.Segment
instance GHC.Classes.Eq Test.DocTest.FuzzySyntax.Segment


-- | Fuzzy matching logic used for doctest output text segments.
module Test.DocTest.FuzzyMatch

-- | Match the <a>String</a> with the given <a>Pattern</a>.
--   
--   <ul>
--   <li>No wildcard:</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; let pat = [Plain "some text\nwithout wildcard"]
--   
--   &gt;&gt;&gt; pat `match` "some text\nwithout wildcard"
--   True
--   </pre>
--   
--   <ul>
--   <li>Inline wildcard:</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; let pat = [Plain "some ", InlineDots, Plain " text"]
--   
--   &gt;&gt;&gt; pat `match` "some single-line text"
--   True
--   
--   &gt;&gt;&gt; pat `match` "some\nmultiline\ntext"
--   False
--   </pre>
--   
--   <ul>
--   <li>Multiline wildcard:</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; let pat = [Plain "some\n", MultilineDots, Plain "\ntext"]
--   
--   &gt;&gt;&gt; pat `match` "some\nmultiline\ntext"
--   True
--   
--   &gt;&gt;&gt; pat `match` "some\n\ntext"
--   True
--   
--   &gt;&gt;&gt; pat `match` "some\nmulti\nline\ntext"
--   True
--   </pre>
--   
--   <ul>
--   <li>Blank line:</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; let pat = [Plain "a blank\n", BlankLine, Plain "\nline"]
--   
--   &gt;&gt;&gt; pat `match` "a blank\n\nline"
--   True
--   
--   &gt;&gt;&gt; pat `match` "a blank\n(not)\nline"
--   False
--   </pre>
match :: Pattern -> String -> Bool


-- | Support functions used by code generated by <tt>doctest-driver</tt>.
module Test.DocTest.Support

-- | Expect that the value <tt>a</tt>, when <a>show</a>n, <a>match</a>es
--   the pattern string.
--   
--   Simple usage: no pattern in the pattern string.
--   
--   <pre>
--   &gt;&gt;&gt; try @HUnitFailure ((123 :: Int) `shouldMatch` "123")
--   Right ()
--   
--   &gt;&gt;&gt; try @HUnitFailure ((123 :: Int) `shouldMatch` "000")
--   Left (HUnitFailure (Just (SrcLoc {...})) (ExpectedButGot Nothing "000" "123"))
--   
--   &gt;&gt;&gt; try @HUnitFailure ("测试«αβ»" `shouldMatch` "\"\\27979\\35797\\171\\945\\946\\187\"")
--   Right ()
--   </pre>
--   
--   Advanced usage: <tt>...</tt> for inline and multiline wildcard.
--   
--   <pre>
--   &gt;&gt;&gt; try @HUnitFailure (True `shouldMatch` "T...e")
--   Right ()
--   
--   &gt;&gt;&gt; try @HUnitFailure ("some fancy string" `shouldMatch` "\"some ... string\"")
--   Right ()
--   </pre>
--   
--   <pre>
--   -- doctest:setup-top
--   data Verbatim = Verbatim String
--   instance Show Verbatim where show (Verbatim s) = s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; try @HUnitFailure (Verbatim "aaa\n\nbbb" `shouldMatch` "aaa\n...\nbbb")
--   Right ()
--   
--   &gt;&gt;&gt; try @HUnitFailure (Verbatim "aaa\nccc\nddd\nbbb" `shouldMatch` "aaa\n...\nbbb")
--   Right ()
--   </pre>
shouldMatch :: (HasCallStack, ReplAction a, Show (ReplResult a)) => a -> String -> Assertion
infix 1 `shouldMatch`

-- | Result type of running as a <a>ReplAction</a>. Unfortunately, this
--   cannot handle polymorphic types without a known top-level type
--   constructor.
type family ReplResult (a :: Type) :: Type

-- | GHCi session supports both evaluating pure values and running
--   <a>IO</a> actions. Use this type class to let the compiler deduce
--   which one a test line should use.
class ReplAction a

-- | Embed into an <a>IO</a> action.
--   
--   <pre>
--   &gt;&gt;&gt; replAction (123 :: Int)
--   123
--   
--   &gt;&gt;&gt; replAction (pure 123 :: IO Int)
--   123
--   </pre>
replAction :: ReplAction a => a -> IO (ReplResult a)

-- | Create a temporary file, write the given contents, run the action with
--   the <a>FilePath</a>, and remove the file at last. Used to implement
--   <a>FilePath</a> captures.
withWriteTempFile :: (FilePath -> IO a) -> String -> IO a

-- | Convert a string to strict text.
textStrict :: String -> Text

-- | Convert a string to lazy text.
textLazy :: String -> Text

-- | Convert a string to strict byte string.
byteStringStrict :: String -> ByteString

-- | Convert a string to lazy byte string.
byteStringLazy :: String -> LazyByteString

-- | Convert a string to short byte string.
shortByteString :: String -> ShortByteString

-- | No-op function. Used to silence the "variable unused" warning.
markUsed :: a -> IO ()
instance (a GHC.Types.~ Test.DocTest.Support.ReplResult a) => Test.DocTest.Support.ReplAction a
instance Test.DocTest.Support.ReplAction (GHC.Types.IO a)
