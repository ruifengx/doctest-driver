-- | Description: Support functions for DocTest-driver.
-- Copyright: Copyright 2024, Ruifeng Xie
-- License: LGPL-3.0-or-later
-- Maintainer: Ruifeng Xie <ruifengx@outlook.com>
--
-- Support functions used by code generated by DocTest-driver.
module Test.DocTest.Support
  -- NOTE: empty lines are significant
  -- they prevent sections from being joint with previous paragraphs

  -- * Usage
  -- | Here we demonstrate features of @doctest-driver@. Readers of this documentation are
  -- encouraged to also refer to the source code of this module as an illustration.

  -- ** Captures
  -- | Sometimes we need some textual contents in our tests, and it might also be useful to let the
  -- user see them while browsing the documentation. In such cases, we can use the @doctest:capture@
  -- instruction.
  --
  -- It is most natural to start with the test cases making use of the captured variable:
  --
  -- >>> take 15 stringCapture
  -- "This text block"
  -- >>> length (lines stringCapture)
  -- 2
  --
  -- and show its contents afterwards:
  --
  -- > -- doctest:capture(stringCapture :: String)
  -- > This text block is supposed to be captured as a String variable.
  -- > Everything besides the first line (the doctest instruction) is captured verbatim.
  --
  -- Sometimes, our tests expect the contents to be saved somewhere as a file. The @capture@
  -- instruction conveniently allow specifying the variable to have type 'FilePath' in such cases:
  --
  -- > -- doctest:capture(fileCapture :: FilePath)
  -- > This text block will be saved to a temporary file.
  -- > The file is written once and reused for all test cases in this group.
  -- > Therefore, it is only suitable for reading.
  -- > For advanced usage involving editing and deletion, use a String capture with a "before" or "around" hook.
  --
  -- The @fileCapture :: 'FilePath'@ variable is then available for use.
  --
  -- >>> fileContents <- readFile fileCapture
  -- >>> length (lines fileContents)
  -- 4
  -- >>> lines fileContents !! 2
  -- "Therefore, it is only suitable for reading."
  --
  -- We can also capture texts as @Text@s and @ByteString@s (strict or lazy).

  -- * Support API
  -- | Here is the API used by tests generated by doctest-driver.
  ( shouldMatch
  , ReplResult
  , ReplAction (..)
  , withWriteTempFile
  , markUsed
  ) where

import Control.DeepSeq (deepseq)
import Control.Exception (throwIO)
import Control.Monad (unless)
import Data.CallStack (HasCallStack, SrcLoc, callStack)
import Data.Kind (Type)
import Data.List.NonEmpty (NonEmpty ((:|)))
import Data.List.NonEmpty qualified as N (last)
import System.IO (hClose, hPutStr, hSetBinaryMode)
import System.IO.Temp (withSystemTempFile)
import Test.DocTest.FuzzyMatch (match)
import Test.DocTest.FuzzySyntax (parsePattern)
import Test.HUnit.Lang (Assertion, FailureReason (..), HUnitFailure (..))

lastMaybe :: [a] -> Maybe a
lastMaybe []       = Nothing
lastMaybe (x : xs) = Just (N.last (x :| xs))

location :: HasCallStack => Maybe SrcLoc
location = snd <$> lastMaybe callStack

infix 1 `shouldMatch`

-- $setup
-- >>> import Control.Exception (try)
-- >>> import Test.HUnit.Lang
-- >>> import Test.DocTest.FuzzyMatch
-- >>> import Test.DocTest.FuzzySyntax

-- | Expect that the value @a@, when 'show'n, 'match'es the pattern string.
--
-- Simple usage: no pattern in the pattern string.
--
-- >>> try @HUnitFailure ((123 :: Int) `shouldMatch` "123")
-- Right ()
-- >>> try @HUnitFailure ((123 :: Int) `shouldMatch` "000")
-- Left (HUnitFailure (Just (SrcLoc {...})) (ExpectedButGot Nothing "000" "123"))
-- >>> try @HUnitFailure ("测试«αβ»" `shouldMatch` "\"\\27979\\35797\\171\\945\\946\\187\"")
-- Right ()
--
-- Advanced usage: @...@ for inline and multiline wildcard.
--
-- >>> try @HUnitFailure (True `shouldMatch` "T...e")
-- Right ()
-- >>> try @HUnitFailure ("some fancy string" `shouldMatch` "\"some ... string\"")
-- Right ()
--
-- > -- doctest:setup-top
-- > data Verbatim = Verbatim String
-- > instance Show Verbatim where show (Verbatim s) = s
--
-- >>> try @HUnitFailure (Verbatim "aaa\n\nbbb" `shouldMatch` "aaa\n...\nbbb")
-- Right ()
-- >>> try @HUnitFailure (Verbatim "aaa\nccc\nddd\nbbb" `shouldMatch` "aaa\n...\nbbb")
-- Right ()
shouldMatch :: (HasCallStack, ReplAction a, Show (ReplResult a)) => a -> String -> Assertion
shouldMatch actual expected = do
  sActual <- show <$> replAction actual
  let err = HUnitFailure location (ExpectedButGot Nothing expected sActual)
  let onError = expected `deepseq` sActual `deepseq` throwIO err
  unless (match (parsePattern expected) sActual) onError

-- | Result type of running as a 'ReplAction'. Unfortunately, this cannot handle polymorphic types
-- without a known top-level type constructor.
type family ReplResult (a :: Type) :: Type where
  ReplResult (IO a) = a
  ReplResult a = a

-- | GHCi session supports both evaluating pure values and running 'IO' actions. Use this type
-- class to let the compiler deduce which one a test line should use.
class ReplAction a where
  -- | Embed into an 'IO' action.
  --
  -- >>> replAction (123 :: Int)
  -- 123
  -- >>> replAction (pure 123 :: IO Int)
  -- 123
  replAction :: a -> IO (ReplResult a)

instance a ~ ReplResult a => ReplAction a where
  replAction = pure

instance {-# OVERLAPPING #-} ReplAction (IO a) where
  replAction = id

-- | Create a temporary file, write the given contents, run the action with the 'FilePath', and
-- remove the file at last. Used to implement 'FilePath' captures.
withWriteTempFile :: (FilePath -> IO a) -> String -> IO a
withWriteTempFile act contents = withSystemTempFile "doctest.txt" go
  where go path h = hSetBinaryMode h True *> hPutStr h contents *> hClose h *> act path

-- | No-op function. Used to silence the "variable unused" warning.
markUsed :: a -> IO ()
markUsed _ = pure ()
{-# INLINE markUsed #-}
