-- | Description: DocTest code generation.
-- Copyright: Copyright 2024, Ruifeng Xie
-- License: AGPL-3.0-or-later
-- Maintainer: Ruifeng Xie <ruifengx@outlook.com>
--
-- Generating DocTests from extracted information.
{-# LANGUAGE OverloadedStrings #-}
module Test.DocTest.Driver.CodeGen
  ( CodeGen
  , Doc
  , runDoc
  , genModuleDoc
  , codeGen
  , codeGenSingle
  ) where

import Test.DocTest.Driver.Extract
import Test.DocTest.Driver.Extract.Dump (hPrintDoc)

import Control.Arrow (Arrow (second), (&&&))
import Control.Monad (unless, when)
import Control.Monad.Reader (MonadReader (ask, local), ReaderT (..), asks, runReaderT)
import Control.Monad.State (MonadState (get, put), State, evalState)
import Control.Monad.Writer (MonadWriter (pass, tell), WriterT (..), execWriterT)
import Data.Char (isSpace)
import Data.Coerce (coerce)
import Data.Foldable (fold)
import Data.List (intercalate, intersperse, uncons)
import Data.List.NonEmpty (NonEmpty ((:|)))
import Data.List.NonEmpty qualified as NonEmpty (fromList, head, toList)
import Data.Maybe (fromJust)
import Data.Monoid (Ap (Ap))
import Data.String (IsString (fromString))
import GHC.Show (showLitString)
import System.Directory (createDirectoryIfMissing)
import System.FilePath (takeDirectory, (</>))
import System.IO (IOMode (WriteMode), withFile)

import GHC.Data.FastString (FastString, unpackFS)
import GHC.Types.SrcLoc (RealSrcLoc, srcLocCol, srcLocFile, srcLocLine)
import GHC.Utils.Ppr qualified as P

import Data.Version (showVersion)
import PackageInfo_doctest_driver qualified as Info

newtype MDoc = MDoc P.Doc

instance Semigroup MDoc where
  MDoc l <> MDoc r = MDoc (l P.<> r)

instance Monoid MDoc where
  mempty = MDoc P.empty

type FileLine = (FastString, Int)
type MFileLine = Maybe FileLine

type CodeGenM = WriterT MDoc (ReaderT [String] (State MFileLine))

-- | Code generation monad.
--
-- * Collects generated text in a GHC 'P.Doc'.
-- * Tracks the file name and the line number for current line. We emit @{-# LINE ... #-}@ pragmas
--   into the generated modules, but line numbers also increase by one naturally after a linebreak.
--   If the file name does not change, and the natural line number matches the expected one, then
--   we omit the @{-# LINE ... #-}@ pragma to avoid cluttering the output.
newtype CodeGen a = Doc (CodeGenM a)
  deriving (Semigroup, Monoid) via Ap CodeGenM a
  deriving (Functor, Applicative, Monad) via CodeGenM
  deriving (MonadReader [String], MonadWriter MDoc, MonadState MFileLine) via CodeGenM

-- | A document is code generation without a separate result.
type Doc = CodeGen ()

wrapDoc :: P.Doc -> Doc
wrapDoc = Doc . tell . MDoc

-- | Run the code generation and get the generated GHC 'P.Doc'.
runDoc :: [String] -> Doc -> P.Doc
runDoc vars (Doc d) = res
  where MDoc res = evalState (runReaderT (execWriterT d) vars) Nothing

instance IsString Doc where
  fromString = text

text :: String -> Doc
text = wrapDoc . P.text

textShow :: Show a => a -> Doc
textShow = text . show

infixr 6 <+>
(<+>) :: Doc -> Doc -> Doc
Doc l <+> Doc r = Doc (WriterT (combine <$> execWriterT l <*> execWriterT r))
  where combine (MDoc dl) (MDoc dr) = ((), MDoc (dl P.<+> dr))

infixl 5 $$
($$) :: Doc -> Doc -> Doc
Doc l $$ Doc r = Doc $ WriterT do
  MDoc dl <- execWriterT l
  originalLoc <- get
  unless (P.isEmpty dl) (put (fmap (second succ) originalLoc))
  MDoc dr <- execWriterT r
  when (P.isEmpty dr) (put originalLoc)
  pure ((), MDoc (dl P.$$ dr))

hcat :: Foldable f => f Doc -> Doc
hcat = fold

vcat :: Foldable f => f Doc -> Doc
vcat = foldr ($$) mempty

emptyText :: Doc
emptyText = wrapDoc P.emptyText

nest :: Int -> Doc -> Doc
nest n = pass . fmap (, coerce (P.nest n))

realLocDoc :: Doc -> RealSrcLoc -> Doc
realLocDoc prefix loc = do
  let lineInfo = srcLocFile &&& srcLocLine
  let newInfo@(file, line) = lineInfo loc
  let linePragma = "{-# LINE " <> textShow line <+> textShow file <> " #-}"
  let colPragma = prefix <> "{-# COLUMN " <> textShow (srcLocCol loc) <> " #-}"
  currentLoc <- get
  if currentLoc == Just newInfo then colPragma else linePragma $$ colPragma
  put (Just newInfo)

locDoc :: Doc -> Loc -> Doc
locDoc prefix = either (const prefix) (realLocDoc prefix)

locLine :: Loc -> String
locLine = either unpackFS (\l -> "line " <> show (srcLocLine l))

noteGenerated :: Doc
noteGenerated = "-- autogenerated by "
  <> text Info.name <+> text (showVersion Info.version)
  <> ", edits will be overwritten upon next build"

-- | Code generation entry-point for an extracted 'Module'.
genModuleDoc :: Module -> Doc
genModuleDoc m = vcat
  [ noteGenerated
  -- this is unfortunate, but we must import the target module unconditionally, and when the
  -- doctests do not use anything from that module (e.g., when there is no doctest at all), the
  -- import becomes redundant and triggers a warning
  , "{-# OPTIONS_GHC -Wno-unused-imports #-}"
  , "module DocTests." <> text modulePath <> " (spec) where"
  , emptyText
  , "import Test.Hspec"
  , "import Test.Hspec.QuickCheck"
  , "import Test.DocTest.Support"
  , emptyText
  , "import " <> text modulePath
  , emptyText
  , vcat (map genImport m.importList)
  , emptyText
  , vcat (map lineDoc m.topSetup)
  , emptyText
  , "spec :: Spec"
  , if null m.testCases then "spec = pure ()" else header $$ contents
  ]
  where modulePath = intercalate "." m.modulePath
        contents = nest 2 (vcat (map genDocTests m.testCases))
        header = "spec = describe " <> textShow modulePath <> " $ do"

lineDoc :: DocLine -> Doc
lineDoc l = text white <> locDoc mempty real.location <> text real.textLine
  where (white, real) = spanDocLine isSpace l

genImport :: DocLine -> Doc
genImport l = locDoc mempty l.location <> text l.textLine

genDocTestList :: Maybe Doc -> [DocTests] -> Doc
genDocTestList (Just name) [] = "pendingWith \"group with" <+> name <+> "but no test\""
genDocTestList Nothing     [] = "pure ()"
genDocTestList _           ts = vcat (map genDocTests ts)

genDocTests :: DocTests -> Doc
genDocTests (Group name loc tests) = header $$ nest 2 (genDocTestList Nothing tests)
  where header = "describe " <> textShow (show name <> groupName) <> " $ do"
        groupName = either (const "") (\l -> " (line " <> show (srcLocLine l) <> ")") loc
genDocTests (TestExample exampleLines) = header $$ nest 2 contents
  where header = "it" <+> label <+> "$" <+> bindVars <+> "do"
        label = textShow ("example group (" <> locLine loc <> ")")
        loc = let l = NonEmpty.head exampleLines in l.programLine.location
        contents = markVarsUsed $$ vcat (fmap genExample exampleLines)
genDocTests (TestProperty propLine) = genProperty propLine
genDocTests (TestMultiline testLines) = genMultiline testLines
genDocTests (TestHook hook tests) = genHook hook (genDocTestList (Just "hook") tests)
genDocTests (Capture content tests) = genCapture content (genDocTestList (Just "capture") tests)
genDocTests (Warning loc msg) = genWarning loc msg

genExample :: ExampleLine -> Doc
genExample l
  | null l.expectedOutput = program
  | otherwise = "(" <> program <> ")" $$ nest 2 ("`shouldMatch`" $$ expected)
  where program = lineDoc l.programLine
        expected = multilineString ((.textLine) <$> NonEmpty.fromList l.expectedOutput)

genProperty :: NonEmpty DocLine -> Doc
genProperty propLines = header $$ nest 2 (vcat (fmap lineDoc propLines))
  where header = "prop " <> textShow line <> " $"
        line = "property (" <> locLine ((.location) (NonEmpty.head propLines)) <> ")"

genMultiline :: NonEmpty DocLine -> Doc
genMultiline ls@(l :| _) = header $$ nest 2 program
  where header = "it" <+> textShow label <+> "$" <+> bindVars <+> "do"
        label = "example (" <> locLine l.location <> ")"
        program = markVarsUsed $$ vcat (map lineDoc (NonEmpty.toList ls))

genHook :: IOHook -> Doc -> Doc
genHook hook = hookGenFunction hook.flavour hook.variables (vcat (fmap lineDoc hook.setupCode))

hookGenFunction :: HookFlavour -> [String] -> Doc -> Doc -> Doc
hookGenFunction Before    = genBeforeHook "before"
hookGenFunction BeforeAll = genBeforeHook "beforeAll"
hookGenFunction After     = genAfterHook "after"
hookGenFunction AfterAll  = genAfterHook "afterAll"
hookGenFunction Around    = uncurry (genAroundHook "around") . fromJust . uncons
hookGenFunction AroundAll = uncurry (genAroundHook "aroundAll") . fromJust . uncons

genBinders :: [String] -> Doc
genBinders []   = error "avoid generating binders when no variable is in scope"
genBinders [x]  = text x
genBinders vars = "(" <> hcat (intersperse ", " (map text vars)) <> ")"

markVarsUsed :: Doc
markVarsUsed = ask >>= \vars -> unless (null vars) ("markUsed" <+> genBinders vars)

bindVars :: Doc
bindVars = ask >>= \vars -> unless (null vars) ("\\" <> genBinders vars <+> "->")

genBeforeHook, genAfterHook :: String -> [String] -> Doc -> Doc -> Doc
genBeforeHook flavour vars hookBody tests = do
  oldVars <- ask
  -- null vars: no new variables added, use before[All]_
  -- null oldVars: no old variables (we can just return vars), use before[All]
  -- otherwise: get old variables and add new, use before[All]With
  let hookFunc = text flavour <> if null vars then "_" else unless (null oldVars) "With"
  -- oldVars binders: bind every old variable in sequence
  let binders = unless (null vars || null oldVars) ("\\" <> genBinders oldVars <+> "->")
  let updateVars = unless (null vars && null oldVars) ("pure" <+> genBinders (vars ++ oldVars))
  let hook = "(" <> binders <+> "do" <+> (hookBody $$ updateVars) <> ")"
  hookFunc $$ nest 2 (hook <+> "do" $$ local (++ vars) tests)
genAfterHook flavour vars hookBody tests = do
  let hookFunc = text flavour <> when (null vars) "_"
  oldVars <- asks (map (\x -> if x `elem` vars then x else "_"))
  -- oldVars binders: bind every (used) old variable in sequence
  let binders = unless (null vars) ("\\" <> genBinders oldVars <+> "->")
  let hook = "(" <> binders <+> "do" <+> hookBody <> ")"
  hookFunc $$ nest 2 (hook <+> "do" $$ local (++ vars) tests)

genAroundHook :: String -> String -> [String] -> Doc -> Doc -> Doc
genAroundHook flavour cont vars hookBody tests = do
  oldVars <- asks (map (\x -> if x `elem` vars then x else "_"))
  -- hookFunc & binders: same with genBeforeHook
  let hookFunc = text flavour <> if null vars then "_" else unless (null oldVars) "With"
  let binders = "\\" <> text cont <+> unless (null vars || null oldVars) (genBinders oldVars) <+> "->"
  let hook = "(" <> binders <+> "do" <+> hookBody <> ")"
  hookFunc $$ nest 2 (hook <+> "do" $$ local (++ vars) tests)

genCapture :: CapturedContent -> Doc -> Doc
genCapture content tests = case content.captureMethod of
  String           -> pureBind mempty
  TextStrict       -> pureBind "textStrict"
  TextLazy         -> pureBind "textLazy"
  ByteStringStrict -> pureBind "byteStringStrict"
  ByteStringLazy   -> pureBind "byteStringLazy"
  ShortByteString  -> pureBind "shortByteString"
  TempFile         -> genAroundHook "aroundAll" "doctest_cont" [content.variableName] hookBody tests
  where s = multilineString content.textContent
        pureBind f = "let" <+> (text content.variableName <+> "=" <+> f $$ nest 2 s) $$ tests
        hookBody = "withWriteTempFile (\\" <> cont <> ")" $$ nest 2 s
        cont = text content.variableName <+> "-> doctest_cont" <+> vars
        vars = asks (++ [content.variableName]) >>= genBinders

genWarning :: Loc -> String -> Doc
genWarning loc msg = "pendingWith" <+> textShow (locLine loc ++ ": " ++ msg)

multilineString :: NonEmpty String -> Doc
multilineString (l :| ls) = if null ls then textShow l else firstLine $$ go ls
  where go []       = error "impossible"
        go [x]      = text ('\\' : showLitString x "\"")
        go (x : xs) = text ('\\' : showLitString x "\\n\\") $$ go xs
        firstLine = text ('"' : showLitString l "\\n\\")

genMainDoc :: [Module] -> Doc
genMainDoc ms = vcat
  [ noteGenerated
  , "module Main (main) where"
  , emptyText
  , "import Test.Hspec"
  , emptyText
  , importList
  , emptyText
  , "main :: IO ()"
  , "main = hspec $ do"
  , nest 2 testList
  ]
  where importList = vcat (map ("import qualified " <>) modulePaths)
        testList = vcat (map (<> ".spec") modulePaths)
        modulePaths = map modulePath ms
        modulePath m = "DocTests." <> text (intercalate "." m.modulePath)

writeToFile :: FilePath -> Doc -> IO ()
writeToFile path doc = do
  createDirectoryIfMissing True (takeDirectory path)
  withFile path WriteMode \hFile -> hPrintDoc hFile (runDoc [] doc)

-- | Perform code generation for a single extracted 'Module'.
codeGenSingle :: FilePath -> Module -> IO FilePath
codeGenSingle root m = do
  let modulePath = "DocTests" : m.modulePath
  let path = root </> foldr (</>) "" modulePath <> ".hs"
  writeToFile path (genModuleDoc m)
  pure (intercalate "." modulePath)

codeGenMain :: FilePath -> [Module] -> IO ()
codeGenMain root ms = writeToFile (root </> "Main.hs") (genMainDoc ms)

-- | Perform code generation for all extracted 'Module's, together with a @Main@ module.
codeGen :: FilePath -> [Module] -> IO [FilePath]
codeGen root ms = do
  codeGenMain root ms
  traverse (codeGenSingle root) ms
