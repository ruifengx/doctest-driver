-- | Description: DocTest code generation.
-- Copyright: Copyright 2024, Ruifeng Xie
-- License: AGPL-3.0-or-later
-- Maintainer: Ruifeng Xie <ruifengx@outlook.com>
--
-- Generating DocTests from extracted information.
{-# LANGUAGE OverloadedStrings #-}
module Test.DocTest.Driver.CodeGen
  ( CodeGen
  , Doc
  , runDoc
  , genModuleDoc
  , codeGen
  , codeGenSingle
  ) where

import Test.DocTest.Driver.Extract
import Test.DocTest.Driver.Extract.Dump (hPrintDoc)

import Control.Arrow (Arrow (second), (&&&))
import Control.Monad (unless, when)
import Control.Monad.Reader (MonadReader (ask, local), ReaderT (..), asks, runReaderT)
import Control.Monad.State (MonadState (get, put), State, evalState)
import Control.Monad.Writer (MonadWriter (pass, tell), WriterT (..), execWriterT)
import Data.Char (isSpace)
import Data.Coerce (coerce)
import Data.List (intercalate, intersperse)
import Data.List.NonEmpty (NonEmpty ((:|)))
import Data.List.NonEmpty qualified as NonEmpty (fromList, head, toList)
import Data.Monoid (Ap (Ap))
import Data.String (IsString (fromString))
import GHC.Show (showLitString)
import System.Directory (createDirectoryIfMissing)
import System.FilePath (takeDirectory, (</>))
import System.IO (IOMode (WriteMode), withFile)

import GHC.Data.FastString (FastString, unpackFS)
import GHC.Types.SrcLoc (RealSrcLoc, srcLocCol, srcLocFile, srcLocLine)
import GHC.Utils.Ppr qualified as P

import Data.Version (showVersion)
import PackageInfo_doctest_driver qualified as Info

newtype MDoc = MDoc P.Doc

instance Semigroup MDoc where
  MDoc l <> MDoc r = MDoc (l P.<> r)

instance Monoid MDoc where
  mempty = MDoc P.empty

type FileLine = (FastString, Int)
type MFileLine = Maybe FileLine

type CodeGenM = WriterT MDoc (ReaderT [String] (State MFileLine))

-- | Code generation monad.
--
-- * Collects generated text in a GHC 'P.Doc'.
-- * Tracks the file name and the line number for current line. We emit @{-# LINE ... #-}@ pragmas
--   into the generated modules, but line numbers also increase by one naturally after a linebreak.
--   If the file name does not change, and the natural line number matches the expected one, then
--   we omit the @{-# LINE ... #-}@ pragma to avoid cluttering the output.
newtype CodeGen a = Doc (CodeGenM a)
  deriving (Semigroup, Monoid) via Ap CodeGenM a
  deriving (Functor, Applicative, Monad) via CodeGenM
  deriving (MonadReader [String], MonadWriter MDoc, MonadState MFileLine) via CodeGenM

-- | A document is code generation without a separate result.
type Doc = CodeGen ()

wrapDoc :: P.Doc -> Doc
wrapDoc = Doc . tell . MDoc

-- | Run the code generation and get the generated GHC 'P.Doc'.
runDoc :: [String] -> Doc -> P.Doc
runDoc vars (Doc d) = res
  where MDoc res = evalState (runReaderT (execWriterT d) vars) Nothing

instance IsString Doc where
  fromString = text

text :: String -> Doc
text = wrapDoc . P.text

textShow :: Show a => a -> Doc
textShow = text . show

infixr 6 <+>
(<+>) :: Doc -> Doc -> Doc
Doc l <+> Doc r = Doc (WriterT (combine <$> execWriterT l <*> execWriterT r))
  where combine (MDoc dl) (MDoc dr) = ((), MDoc (dl P.<+> dr))

infixl 5 $$
($$) :: Doc -> Doc -> Doc
Doc l $$ Doc r = Doc $ WriterT do
  MDoc dl <- execWriterT l
  originalLoc <- get
  unless (P.isEmpty dl) (put (fmap (second succ) originalLoc))
  MDoc dr <- execWriterT r
  when (P.isEmpty dr) (put originalLoc)
  pure ((), MDoc (dl P.$$ dr))

hcat :: Foldable f => f Doc -> Doc
hcat = foldr (<>) mempty

vcat :: Foldable f => f Doc -> Doc
vcat = foldr ($$) mempty

emptyText :: Doc
emptyText = wrapDoc P.emptyText

nest :: Int -> Doc -> Doc
nest n = pass . fmap (, coerce (P.nest n))

realLocDoc :: Doc -> RealSrcLoc -> Doc
realLocDoc prefix loc = do
  let lineInfo = srcLocFile &&& srcLocLine
  let newInfo@(file, line) = lineInfo loc
  let linePragma = "{-# LINE " <> textShow line <+> textShow file <> " #-}"
  let colPragma = prefix <> "{-# COLUMN " <> textShow (srcLocCol loc) <> " #-}"
  currentLoc <- get
  if currentLoc == Just newInfo then colPragma else linePragma $$ colPragma
  put (Just newInfo)

locDoc :: Doc -> Loc -> Doc
locDoc prefix = either (const prefix) (realLocDoc prefix)

locLine :: Loc -> String
locLine = either unpackFS (\l -> "line " <> show (srcLocLine l))

noteGenerated :: Doc
noteGenerated = "-- autogenerated by "
  <> text Info.name <+> text (showVersion Info.version)
  <> ", edits will be overwritten upon next build"

-- | Code generation entry-point for an extracted 'Module'.
genModuleDoc :: Module -> Doc
genModuleDoc m = vcat
  [ noteGenerated
  -- this is unfortunate, but we must import the target module unconditionally, and when the
  -- doctests do not use anything from that module (e.g., when there is no doctest at all), the
  -- import becomes redundant and triggers a warning
  , "{-# OPTIONS_GHC -Wno-unused-imports #-}"
  , "module DocTests." <> text modulePath <> " (spec) where"
  , emptyText
  , "import Test.Hspec"
  , "import Test.Hspec.QuickCheck"
  , "import Test.DocTest.Support"
  , emptyText
  , "import " <> text modulePath
  , emptyText
  , vcat (map genImport m.importList)
  , emptyText
  , vcat (map lineDoc m.topSetup)
  , emptyText
  , "spec :: Spec"
  , if null m.testCases then "spec = pure ()" else header $$ contents
  ]
  where modulePath = intercalate "." m.modulePath
        contents = nest 2 (vcat (map genDocTests m.testCases))
        header = "spec = describe " <> textShow modulePath <> " $ do"

lineDoc :: DocLine -> Doc
lineDoc l = text white <> locDoc mempty real.location <> text real.textLine
  where (white, real) = spanDocLine isSpace l

genImport :: DocLine -> Doc
genImport l = locDoc mempty l.location <> text l.textLine

genDocTestList :: Maybe Doc -> [DocTests] -> Doc
genDocTestList (Just name) [] = "pendingWith \"group with" <+> name <+> "but no test\""
genDocTestList Nothing     [] = "pure ()"
genDocTestList _           ts = vcat (map genDocTests ts)

genDocTests :: DocTests -> Doc
genDocTests (Group name loc tests) = header $$ nest 2 (genDocTestList Nothing tests)
  where header = "describe " <> textShow (show name <> groupName) <> " $ do"
        groupName = either (const "") (\l -> " (line " <> show (srcLocLine l) <> ")") loc
genDocTests (TestExample exampleLines) = header $$ nest 2 contents
  where header = if nTests == 1 then "do" else
          key <+> label <+> "$" <+> when (nTests == 0) bindVars <+> "do"
        key = if nTests == 0 then "it" else "describe"
        nTests = testCount exampleLines
        -- nTests == 0: use "it", the whole group is a test, but no "it" for example lines
        -- nTests == 1: use "do", no need to introduce the group layer for a single test
        -- nTests == 2: use "describe", we need a group only in this case
        label = textShow ("example group (" <> locLine loc <> ")")
        loc = let l = NonEmpty.head exampleLines in l.programLine.location
        contents = vcat (fmap genExample exampleLines)
genDocTests (TestProperty propLine) = genProperty propLine
genDocTests (TestMultiline testLines) = genMultiline testLines
genDocTests (TestHook hook tests) = genHook hook (genDocTestList (Just "hook") tests)
genDocTests (Capture content tests) = genCapture content (genDocTestList (Just "capture") tests)
genDocTests (Warning loc msg) = genWarning loc msg

genExample :: ExampleLine -> Doc
genExample l
  | null l.expectedOutput = program
  | otherwise = header $$ nest 2 ("(" <> program <> ")" $$ nest 2 ("`shouldMatch`" $$ expected))
  where header = "it" <+> label <+> "$" <+> bindVars <+> "do"
        label = textShow ("example (" <> locLine l.programLine.location <> ")")
        program = lineDoc l.programLine
        expected = multilineString ((.textLine) <$> NonEmpty.fromList l.expectedOutput)

testCount :: NonEmpty ExampleLine -> Int
testCount = go 0 . NonEmpty.toList
  where go n [] = n
        go n (line : rest)
          | null line.expectedOutput = go n rest
          | n == 1 = 2
          | otherwise = go (succ n) rest

genProperty :: NonEmpty DocLine -> Doc
genProperty propLines = header $$ nest 2 (vcat (fmap lineDoc propLines))
  where header = "prop " <> textShow line <> " $"
        line = "property (" <> locLine ((.location) (NonEmpty.head propLines)) <> ")"

genMultiline :: NonEmpty DocLine -> Doc
genMultiline ls@(l :| _) = header $$ program
  where header = "it" <+> textShow label <+> "$" <+> bindVars <+> "do"
        label = "example (" <> locLine l.location <> ")"
        program = vcat (map lineDoc (NonEmpty.toList ls))

genHook :: IOHook -> Doc -> Doc
genHook hook = genHookRaw hook.flavour hook.variables (vcat (fmap lineDoc hook.setupCode))

isBeforeHook :: HookFlavour -> Bool
isBeforeHook Before    = True
isBeforeHook BeforeAll = True
isBeforeHook After     = False
isBeforeHook AfterAll  = False

genBinders :: [String] -> Doc
genBinders vars = "(" <> hcat (intersperse ", " (map text vars)) <> ")"

bindVars :: Doc
bindVars = ask >>= \vars -> unless (null vars) ("\\" <> genBinders vars <+> "->")

genHookRaw :: HookFlavour -> [String] -> Doc -> Doc -> Doc
genHookRaw flavour vars hookBody tests | isBeforeHook flavour = do
  oldVars <- ask
  -- null vars: no new variables added, use before[All]_
  -- null oldVars: no old variables (we can just return vars), use before[All]
  -- otherwise: get old variables and add new, use before[All]With
  let hookFunc = textShow flavour <> if null vars then "_" else unless (null oldVars) "With"
  -- oldVars binders: bind every old variable in sequence
  let binders = unless (null vars || null oldVars) ("\\" <> genBinders oldVars <+> "->")
  let updateVars = unless (null vars && null oldVars) ("pure" <+> genBinders (vars ++ oldVars))
  let hook = "(" <> binders <+> "do" <+> (hookBody $$ updateVars) <> ")"
  hookFunc $$ nest 2 (hook <+> "do" $$ local (++ vars) tests)
genHookRaw flavour vars hookBody tests = do
  let hookFunc = textShow flavour <> when (null vars) "_"
  oldVars <- asks (map (\x -> if x `elem` vars then x else "_"))
  -- oldVars binders: bind every (used) old variable in sequence
  let binders = unless (null vars) ("\\" <> genBinders oldVars <+> "->")
  let hook = "(" <> binders <+> "do" <+> hookBody <> ")"
  hookFunc $$ nest 2 (hook <+> "do" $$ local (++ vars) tests)

genCapture :: CapturedContent -> Doc -> Doc
genCapture content tests = case content.captureMethod of
  String           -> pureBind mempty
  TextStrict       -> pureBind "textStrict"
  TextLazy         -> pureBind "textLazy"
  ByteStringStrict -> pureBind "byteStringStrict"
  ByteStringLazy   -> pureBind "byteStringLazy"
  ShortByteString  -> pureBind "shortByteString"
  TempFile         -> genHookRaw BeforeAll [content.variableName] hookBody tests
  where s = multilineString content.textContent
        pureBind f = "let" <+> (text content.variableName <+> "=" <+> f $$ nest 2 s) $$ tests
        hookBody = text content.variableName <> " <- writeTempFile" $$ nest 2 s

genWarning :: Loc -> String -> Doc
genWarning loc msg = "pendingWith" <+> textShow (locLine loc ++ ": " ++ msg)

multilineString :: NonEmpty String -> Doc
multilineString (l :| ls) = if null ls then textShow l else firstLine $$ go ls
  where go []       = error "impossible"
        go [x]      = text ('\\' : showLitString x "\"")
        go (x : xs) = text ('\\' : showLitString x "\\n\\") $$ go xs
        firstLine = text ('"' : showLitString l "\\n\\")

genMainDoc :: [Module] -> Doc
genMainDoc ms = vcat
  [ noteGenerated
  , "module Main (main) where"
  , emptyText
  , "import Test.Hspec"
  , emptyText
  , importList
  , emptyText
  , "main :: IO ()"
  , "main = hspec $ do"
  , nest 2 testList
  ]
  where importList = vcat (map ("import qualified " <>) modulePaths)
        testList = vcat (map (<> ".spec") modulePaths)
        modulePaths = map modulePath ms
        modulePath m = "DocTests." <> text (intercalate "." m.modulePath)

writeToFile :: FilePath -> Doc -> IO ()
writeToFile path doc = do
  createDirectoryIfMissing True (takeDirectory path)
  withFile path WriteMode \hFile -> hPrintDoc hFile (runDoc [] doc)

-- | Perform code generation for a single extracted 'Module'.
codeGenSingle :: FilePath -> Module -> IO FilePath
codeGenSingle root m = do
  let modulePath = "DocTests" : m.modulePath
  let path = root </> foldr (</>) "" modulePath <> ".hs"
  writeToFile path (genModuleDoc m)
  pure (intercalate "." modulePath)

codeGenMain :: FilePath -> [Module] -> IO ()
codeGenMain root ms = writeToFile (root </> "Main.hs") (genMainDoc ms)

-- | Perform code generation for all extracted 'Module's, together with a @Main@ module.
codeGen :: FilePath -> [Module] -> IO [FilePath]
codeGen root ms = do
  codeGenMain root ms
  traverse (codeGenSingle root) ms
